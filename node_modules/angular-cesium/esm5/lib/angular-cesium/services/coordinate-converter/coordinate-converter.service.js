/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Injectable, Optional } from '@angular/core';
import { CesiumService } from '../cesium/cesium.service';
import * as geodesy from 'geodesy';
import { LatLonEllipsoidal, Utm } from 'geodesy';
/** @type {?} */
var LatLonVectors = geodesy['LatLonVectors'];
// doesnt exists on typings
window['geodesy'] = geodesy;
/**
 *  Given different types of coordinates, we provide you a service converting those types to the most common other types.
 *  We are using the geodesy implementation of UTM conversion. see: https://github.com/chrisveness/geodesy.
 *
 * \@example
 * import { Component, OnInit } from '\@angular/core';
 * import { CoordinateConverter } from 'angular2-cesium';
 *
 * \@Component({
 * 		selector:'my-component',
 * 		template:'<div>{{showCartographic}}</div>',
 * 		providers:[CoordinateConverter]
 * })
 * export class MyComponent implements OnInit {
 * 		showCartographic;
 *
 * 		constructor(private coordinateConverter:CoordinateConverter){
 * 		}
 *
 * 		ngOnInit(){
 * 			this.showCartographic = this.coordinateConverter.degreesToCartographic(5, 5, 5);
 *  }
 * }
 *
 */
var CoordinateConverter = /** @class */ (function () {
    function CoordinateConverter(cesiumService) {
        this.cesiumService = cesiumService;
    }
    /**
     * @param {?} cartesian3
     * @param {?=} ellipsoid
     * @return {?}
     */
    CoordinateConverter.cartesian3ToLatLon = /**
     * @param {?} cartesian3
     * @param {?=} ellipsoid
     * @return {?}
     */
    function (cartesian3, ellipsoid) {
        /** @type {?} */
        var cart = Cesium.Cartographic.fromCartesian(cartesian3, ellipsoid);
        return {
            lon: Cesium.Math.toDegrees(cart.longitude),
            lat: Cesium.Math.toDegrees(cart.latitude),
            height: cart.height
        };
    };
    /**
     * @param {?} screenPos
     * @param {?=} addMapCanvasBoundsToPos
     * @return {?}
     */
    CoordinateConverter.prototype.screenToCartesian3 = /**
     * @param {?} screenPos
     * @param {?=} addMapCanvasBoundsToPos
     * @return {?}
     */
    function (screenPos, addMapCanvasBoundsToPos) {
        if (!this.cesiumService) {
            throw new Error('ANGULAR2-CESIUM - Cesium service should be provided in order' +
                ' to do screen position calculations');
        }
        else {
            /** @type {?} */
            var screenPosition = tslib_1.__assign({}, screenPos);
            if (addMapCanvasBoundsToPos) {
                /** @type {?} */
                var mapBounds = this.cesiumService.getViewer().canvas.getBoundingClientRect();
                screenPosition.x += mapBounds.left;
                screenPosition.y += mapBounds.top;
            }
            /** @type {?} */
            var camera = this.cesiumService.getViewer().camera;
            return camera.pickEllipsoid(screenPosition);
        }
    };
    /**
     * @param {?} screenPos
     * @param {?=} ellipsoid
     * @return {?}
     */
    CoordinateConverter.prototype.screenToCartographic = /**
     * @param {?} screenPos
     * @param {?=} ellipsoid
     * @return {?}
     */
    function (screenPos, ellipsoid) {
        return this.cartesian3ToCartographic(this.screenToCartesian3(screenPos), ellipsoid);
    };
    /**
     * @param {?} cartesian
     * @param {?=} ellipsoid
     * @return {?}
     */
    CoordinateConverter.prototype.cartesian3ToCartographic = /**
     * @param {?} cartesian
     * @param {?=} ellipsoid
     * @return {?}
     */
    function (cartesian, ellipsoid) {
        return Cesium.Cartographic.fromCartesian(cartesian, ellipsoid);
    };
    /**
     * @param {?} longitude
     * @param {?} latitude
     * @param {?=} height
     * @return {?}
     */
    CoordinateConverter.prototype.degreesToCartographic = /**
     * @param {?} longitude
     * @param {?} latitude
     * @param {?=} height
     * @return {?}
     */
    function (longitude, latitude, height) {
        return Cesium.Cartographic.fromDegrees(longitude, latitude, height);
    };
    /**
     * @param {?} longitude
     * @param {?} latitude
     * @param {?=} height
     * @return {?}
     */
    CoordinateConverter.prototype.radiansToCartographic = /**
     * @param {?} longitude
     * @param {?} latitude
     * @param {?=} height
     * @return {?}
     */
    function (longitude, latitude, height) {
        return Cesium.Cartographic.fromRadians(longitude, latitude, height);
    };
    /**
     * @param {?} longitude
     * @param {?} latitude
     * @return {?}
     */
    CoordinateConverter.prototype.degreesToUTM = /**
     * @param {?} longitude
     * @param {?} latitude
     * @return {?}
     */
    function (longitude, latitude) {
        return new LatLonEllipsoidal(latitude, longitude).toUtm();
    };
    /**
     * @param {?} zone
     * @param {?} hemisphereType
     * @param {?} easting
     * @param {?} northing
     * @return {?}
     */
    CoordinateConverter.prototype.UTMToDegrees = /**
     * @param {?} zone
     * @param {?} hemisphereType
     * @param {?} easting
     * @param {?} northing
     * @return {?}
     */
    function (zone, hemisphereType, easting, northing) {
        return this.geodesyToCesiumObject(new Utm(zone, hemisphereType, easting, northing).toLatLonE());
    };
    /**
     * @private
     * @param {?} geodesyRadians
     * @return {?}
     */
    CoordinateConverter.prototype.geodesyToCesiumObject = /**
     * @private
     * @param {?} geodesyRadians
     * @return {?}
     */
    function (geodesyRadians) {
        return {
            longitude: geodesyRadians.lon,
            latitude: geodesyRadians.lat,
            height: geodesyRadians['height'] ? geodesyRadians['height'] : 0
        };
    };
    /**
     * middle point between two points
     * @param first  (latitude,longitude) in radians
     * @param second (latitude,longitude) in radians
     */
    /**
     * middle point between two points
     * @param {?} first  (latitude,longitude) in radians
     * @param {?} second (latitude,longitude) in radians
     * @return {?}
     */
    CoordinateConverter.prototype.midPointToCartesian3 = /**
     * middle point between two points
     * @param {?} first  (latitude,longitude) in radians
     * @param {?} second (latitude,longitude) in radians
     * @return {?}
     */
    function (first, second) {
        /** @type {?} */
        var toDeg = function (rad) { return Cesium.Math.toDegrees(rad); };
        /** @type {?} */
        var firstPoint = new LatLonVectors(toDeg(first.latitude), toDeg(first.longitude));
        /** @type {?} */
        var secondPoint = new LatLonVectors(toDeg(second.latitude), toDeg(second.longitude));
        /** @type {?} */
        var middlePoint = firstPoint.midpointTo(secondPoint);
        return Cesium.Cartesian3.fromDegrees(middlePoint.lon, middlePoint.lat);
    };
    /**
     * @param {?} position0
     * @param {?} position1
     * @return {?}
     */
    CoordinateConverter.prototype.middlePointByScreen = /**
     * @param {?} position0
     * @param {?} position1
     * @return {?}
     */
    function (position0, position1) {
        /** @type {?} */
        var scene = this.cesiumService.getScene();
        /** @type {?} */
        var screenPosition1 = Cesium.SceneTransforms.wgs84ToWindowCoordinates(scene, position0);
        /** @type {?} */
        var screenPosition2 = Cesium.SceneTransforms.wgs84ToWindowCoordinates(scene, position1);
        /** @type {?} */
        var middleScreenPoint = new Cesium.Cartesian2((screenPosition2.x + screenPosition1.x) / 2.0, (screenPosition2.y + screenPosition1.y) / 2.0);
        return scene.pickPosition(middleScreenPoint);
    };
    /**
     * initial bearing between two points
     *
     * * @return bearing in degrees
     * @param first - {latitude,longitude} in radians
     * @param second - {latitude,longitude} in radians
     */
    /**
     * initial bearing between two points
     *
     * * \@return bearing in degrees
     * @param {?} first - {latitude,longitude} in radians
     * @param {?} second - {latitude,longitude} in radians
     * @return {?}
     */
    CoordinateConverter.prototype.bearingTo = /**
     * initial bearing between two points
     *
     * * \@return bearing in degrees
     * @param {?} first - {latitude,longitude} in radians
     * @param {?} second - {latitude,longitude} in radians
     * @return {?}
     */
    function (first, second) {
        /** @type {?} */
        var toDeg = function (rad) { return Cesium.Math.toDegrees(rad); };
        /** @type {?} */
        var firstPoint = new LatLonVectors(toDeg(first.latitude), toDeg(first.longitude));
        /** @type {?} */
        var secondPoint = new LatLonVectors(toDeg(second.latitude), toDeg(second.longitude));
        /** @type {?} */
        var bearing = firstPoint.bearingTo(secondPoint);
        return bearing;
    };
    /**
     * initial bearing between two points
     *
     * @return bearing in degrees
     */
    /**
     * initial bearing between two points
     *
     * @param {?} firstCartesian3
     * @param {?} secondCartesian3
     * @return {?} bearing in degrees
     */
    CoordinateConverter.prototype.bearingToCartesian = /**
     * initial bearing between two points
     *
     * @param {?} firstCartesian3
     * @param {?} secondCartesian3
     * @return {?} bearing in degrees
     */
    function (firstCartesian3, secondCartesian3) {
        /** @type {?} */
        var firstCart = Cesium.Cartographic.fromCartesian(firstCartesian3);
        /** @type {?} */
        var secondCart = Cesium.Cartographic.fromCartesian(secondCartesian3);
        return this.bearingTo(firstCart, secondCart);
    };
    CoordinateConverter.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    CoordinateConverter.ctorParameters = function () { return [
        { type: CesiumService, decorators: [{ type: Optional }] }
    ]; };
    return CoordinateConverter;
}());
export { CoordinateConverter };
if (false) {
    /**
     * @type {?}
     * @private
     */
    CoordinateConverter.prototype.cesiumService;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29vcmRpbmF0ZS1jb252ZXJ0ZXIuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2FuZ3VsYXItY2VzaXVtLyIsInNvdXJjZXMiOlsibGliL2FuZ3VsYXItY2VzaXVtL3NlcnZpY2VzL2Nvb3JkaW5hdGUtY29udmVydGVyL2Nvb3JkaW5hdGUtY29udmVydGVyLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLFFBQVEsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNyRCxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFDekQsT0FBTyxLQUFLLE9BQU8sTUFBTSxTQUFTLENBQUM7QUFDbkMsT0FBTyxFQUFzQixpQkFBaUIsRUFBRSxHQUFHLEVBQUUsTUFBTSxTQUFTLENBQUM7O0lBRy9ELGFBQWEsR0FBRyxPQUFPLENBQUMsZUFBZSxDQUFDOztBQUU5QyxNQUFNLENBQUMsU0FBUyxDQUFDLEdBQUcsT0FBTyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTJCNUI7SUFFRSw2QkFBZ0MsYUFBNkI7UUFBN0Isa0JBQWEsR0FBYixhQUFhLENBQWdCO0lBQzdELENBQUM7Ozs7OztJQUVNLHNDQUFrQjs7Ozs7SUFBekIsVUFBMEIsVUFBc0IsRUFBRSxTQUFlOztZQUN6RCxJQUFJLEdBQUcsTUFBTSxDQUFDLFlBQVksQ0FBQyxhQUFhLENBQUMsVUFBVSxFQUFFLFNBQVMsQ0FBQztRQUNyRSxPQUFPO1lBQ0wsR0FBRyxFQUFFLE1BQU0sQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUM7WUFDMUMsR0FBRyxFQUFFLE1BQU0sQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUM7WUFDekMsTUFBTSxFQUFFLElBQUksQ0FBQyxNQUFNO1NBQ3BCLENBQUM7SUFDSixDQUFDOzs7Ozs7SUFFRCxnREFBa0I7Ozs7O0lBQWxC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QUEwQjs7WUFDbkQsVUFBVSxHQUFHLElBQUksYUFBYSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLEVBQUUsS0FBSyxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FBQzs7WUFDN0UsV0FBVyxHQUFHLElBQUksYUFBYSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLEVBQUUsS0FBSyxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQzs7WUFDaEYsT0FBTyxHQUFHLFVBQVUsQ0FBQyxTQUFTLENBQUMsV0FBVyxDQUFDO1FBRWpELE9BQU8sT0FBTyxDQUFDO0lBQ2pCLENBQUM7SUFFRDs7OztPQUlHOzs7Ozs7OztJQUNILGdEQUFrQjs7Ozs7OztJQUFsQixVQUFtQixlQUEyQixFQUFFLGdCQUE0Qjs7WUFDcEUsU0FBUyxHQUFHLE1BQU0sQ0FBQyxZQUFZLENBQUMsYUFBYSxDQUFDLGVBQWUsQ0FBQzs7WUFDOUQsVUFBVSxHQUFHLE1BQU0sQ0FBQyxZQUFZLENBQUMsYUFBYSxDQUFDLGdCQUFnQixDQUFDO1FBRXRFLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxTQUFTLEVBQUUsVUFBVSxDQUFDLENBQUM7SUFDL0MsQ0FBQzs7Z0JBaEhGLFVBQVU7Ozs7Z0JBbENGLGFBQWEsdUJBb0NQLFFBQVE7O0lBK0d2QiwwQkFBQztDQUFBLEFBakhELElBaUhDO1NBaEhZLG1CQUFtQjs7Ozs7O0lBQ2xCLDRDQUFpRCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIE9wdGlvbmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDZXNpdW1TZXJ2aWNlIH0gZnJvbSAnLi4vY2VzaXVtL2Nlc2l1bS5zZXJ2aWNlJztcbmltcG9ydCAqIGFzIGdlb2Rlc3kgZnJvbSAnZ2VvZGVzeSc7XG5pbXBvcnQgeyBoZW1pc3BoZXJlLCBMYXRMb24sIExhdExvbkVsbGlwc29pZGFsLCBVdG0gfSBmcm9tICdnZW9kZXN5JztcbmltcG9ydCB7IENhcnRlc2lhbjMgfSBmcm9tICcuLi8uLi9tb2RlbHMvY2FydGVzaWFuMyc7XG5cbmNvbnN0IExhdExvblZlY3RvcnMgPSBnZW9kZXN5WydMYXRMb25WZWN0b3JzJ107IC8vIGRvZXNudCBleGlzdHMgb24gdHlwaW5nc1xuXG53aW5kb3dbJ2dlb2Rlc3knXSA9IGdlb2Rlc3k7XG5cbi8qKlxuICogIEdpdmVuIGRpZmZlcmVudCB0eXBlcyBvZiBjb29yZGluYXRlcywgd2UgcHJvdmlkZSB5b3UgYSBzZXJ2aWNlIGNvbnZlcnRpbmcgdGhvc2UgdHlwZXMgdG8gdGhlIG1vc3QgY29tbW9uIG90aGVyIHR5cGVzLlxuICogIFdlIGFyZSB1c2luZyB0aGUgZ2VvZGVzeSBpbXBsZW1lbnRhdGlvbiBvZiBVVE0gY29udmVyc2lvbi4gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vY2hyaXN2ZW5lc3MvZ2VvZGVzeS5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgQ29tcG9uZW50LCBPbkluaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqIGltcG9ydCB7IENvb3JkaW5hdGVDb252ZXJ0ZXIgfSBmcm9tICdhbmd1bGFyMi1jZXNpdW0nO1xuICpcbiAqIEBDb21wb25lbnQoe1xuICogXHRcdHNlbGVjdG9yOidteS1jb21wb25lbnQnLFxuICogXHRcdHRlbXBsYXRlOic8ZGl2Pnt7c2hvd0NhcnRvZ3JhcGhpY319PC9kaXY+JyxcbiAqIFx0XHRwcm92aWRlcnM6W0Nvb3JkaW5hdGVDb252ZXJ0ZXJdXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIE15Q29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcbiAqIFx0XHRzaG93Q2FydG9ncmFwaGljO1xuICpcbiAqIFx0XHRjb25zdHJ1Y3Rvcihwcml2YXRlIGNvb3JkaW5hdGVDb252ZXJ0ZXI6Q29vcmRpbmF0ZUNvbnZlcnRlcil7XG4gKiBcdFx0fVxuICpcbiAqIFx0XHRuZ09uSW5pdCgpe1xuICogXHRcdFx0dGhpcy5zaG93Q2FydG9ncmFwaGljID0gdGhpcy5jb29yZGluYXRlQ29udmVydGVyLmRlZ3JlZXNUb0NhcnRvZ3JhcGhpYyg1LCA1LCA1KTtcbiAqICB9XG4gKiB9XG4gKlxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgQ29vcmRpbmF0ZUNvbnZlcnRlciB7XG4gIGNvbnN0cnVjdG9yKEBPcHRpb25hbCgpIHByaXZhdGUgY2VzaXVtU2VydmljZT86IENlc2l1bVNlcnZpY2UpIHtcbiAgfVxuXG4gIHN0YXRpYyBjYXJ0ZXNpYW4zVG9MYXRMb24oY2FydGVzaWFuMzogQ2FydGVzaWFuMywgZWxsaXBzb2lkPzogYW55KToge2xvbjogbnVtYmVyLCBsYXQ6IG51bWJlcjsgaGVpZ2h0OiBudW1iZXJ9IHtcbiAgICBjb25zdCBjYXJ0ID0gQ2VzaXVtLkNhcnRvZ3JhcGhpYy5mcm9tQ2FydGVzaWFuKGNhcnRlc2lhbjMsIGVsbGlwc29pZCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxvbjogQ2VzaXVtLk1hdGgudG9EZWdyZWVzKGNhcnQubG9uZ2l0dWRlKSxcbiAgICAgIGxhdDogQ2VzaXVtLk1hdGgudG9EZWdyZWVzKGNhcnQubGF0aXR1ZGUpLFxuICAgICAgaGVpZ2h0OiBjYXJ0LmhlaWdodFxuICAgIH07XG4gIH1cblxuICBzY3JlZW5Ub0NhcnRlc2lhbjMoc2NyZWVuUG9zOiB7IHg6IG51bWJlciwgeTogbnVtYmVyIH0sIGFkZE1hcENhbnZhc0JvdW5kc1RvUG9zPzogYm9vbGVhbikge1xuICAgIGlmICghdGhpcy5jZXNpdW1TZXJ2aWNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FOR1VMQVIyLUNFU0lVTSAtIENlc2l1bSBzZXJ2aWNlIHNob3VsZCBiZSBwcm92aWRlZCBpbiBvcmRlcicgK1xuICAgICAgICAnIHRvIGRvIHNjcmVlbiBwb3NpdGlvbiBjYWxjdWxhdGlvbnMnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc2NyZWVuUG9zaXRpb24gPSB7IC4uLnNjcmVlblBvcyB9O1xuICAgICAgaWYgKGFkZE1hcENhbnZhc0JvdW5kc1RvUG9zKSB7XG4gICAgICAgIGNvbnN0IG1hcEJvdW5kcyA9IHRoaXMuY2VzaXVtU2VydmljZS5nZXRWaWV3ZXIoKS5jYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHNjcmVlblBvc2l0aW9uLnggKz0gbWFwQm91bmRzLmxlZnQ7XG4gICAgICAgIHNjcmVlblBvc2l0aW9uLnkgKz0gbWFwQm91bmRzLnRvcDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY2FtZXJhID0gdGhpcy5jZXNpdW1TZXJ2aWNlLmdldFZpZXdlcigpLmNhbWVyYTtcbiAgICAgIHJldHVybiBjYW1lcmEucGlja0VsbGlwc29pZChzY3JlZW5Qb3NpdGlvbik7XG4gICAgfVxuICB9XG5cbiAgc2NyZWVuVG9DYXJ0b2dyYXBoaWMoc2NyZWVuUG9zOiB7IHg6IG51bWJlciwgeTogbnVtYmVyIH0sIGVsbGlwc29pZD86IGFueSkge1xuICAgIHJldHVybiB0aGlzLmNhcnRlc2lhbjNUb0NhcnRvZ3JhcGhpYyh0aGlzLnNjcmVlblRvQ2FydGVzaWFuMyhzY3JlZW5Qb3MpLCBlbGxpcHNvaWQpO1xuICB9XG5cbiAgY2FydGVzaWFuM1RvQ2FydG9ncmFwaGljKGNhcnRlc2lhbjogQ2FydGVzaWFuMywgZWxsaXBzb2lkPzogYW55KSB7XG4gICAgcmV0dXJuIENlc2l1bS5DYXJ0b2dyYXBoaWMuZnJvbUNhcnRlc2lhbihjYXJ0ZXNpYW4sIGVsbGlwc29pZCk7XG4gIH1cblxuICBkZWdyZWVzVG9DYXJ0b2dyYXBoaWMobG9uZ2l0dWRlOiBudW1iZXIsIGxhdGl0dWRlOiBudW1iZXIsIGhlaWdodD86IG51bWJlcikge1xuICAgIHJldHVybiBDZXNpdW0uQ2FydG9ncmFwaGljLmZyb21EZWdyZWVzKGxvbmdpdHVkZSwgbGF0aXR1ZGUsIGhlaWdodCk7XG4gIH1cblxuICByYWRpYW5zVG9DYXJ0b2dyYXBoaWMobG9uZ2l0dWRlOiBudW1iZXIsIGxhdGl0dWRlOiBudW1iZXIsIGhlaWdodD86IG51bWJlcikge1xuICAgIHJldHVybiBDZXNpdW0uQ2FydG9ncmFwaGljLmZyb21SYWRpYW5zKGxvbmdpdHVkZSwgbGF0aXR1ZGUsIGhlaWdodCk7XG4gIH1cblxuICBkZWdyZWVzVG9VVE0obG9uZ2l0dWRlOiBudW1iZXIsIGxhdGl0dWRlOiBudW1iZXIpIHtcbiAgICByZXR1cm4gbmV3IExhdExvbkVsbGlwc29pZGFsKGxhdGl0dWRlLCBsb25naXR1ZGUpLnRvVXRtKCk7XG4gIH1cblxuICBVVE1Ub0RlZ3JlZXMoem9uZTogbnVtYmVyLCBoZW1pc3BoZXJlVHlwZTogaGVtaXNwaGVyZSwgZWFzdGluZzogbnVtYmVyLCBub3J0aGluZzogbnVtYmVyKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2VvZGVzeVRvQ2VzaXVtT2JqZWN0KG5ldyBVdG0oem9uZSwgaGVtaXNwaGVyZVR5cGUsIGVhc3RpbmcsIG5vcnRoaW5nKS50b0xhdExvbkUoKSk7XG4gIH1cblxuICBwcml2YXRlIGdlb2Rlc3lUb0Nlc2l1bU9iamVjdChnZW9kZXN5UmFkaWFuczogTGF0TG9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxvbmdpdHVkZTogZ2VvZGVzeVJhZGlhbnMubG9uLFxuICAgICAgbGF0aXR1ZGU6IGdlb2Rlc3lSYWRpYW5zLmxhdCxcbiAgICAgIGhlaWdodDogZ2VvZGVzeVJhZGlhbnNbJ2hlaWdodCddID8gZ2VvZGVzeVJhZGlhbnNbJ2hlaWdodCddIDogMFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogbWlkZGxlIHBvaW50IGJldHdlZW4gdHdvIHBvaW50c1xuICAgKiBAcGFyYW0gZmlyc3QgIChsYXRpdHVkZSxsb25naXR1ZGUpIGluIHJhZGlhbnNcbiAgICogQHBhcmFtIHNlY29uZCAobGF0aXR1ZGUsbG9uZ2l0dWRlKSBpbiByYWRpYW5zXG4gICAqL1xuICBtaWRQb2ludFRvQ2FydGVzaWFuMyhmaXJzdDogeyBsYXRpdHVkZTogbnVtYmVyLCBsb25naXR1ZGU6IG51bWJlciB9LCBzZWNvbmQ6IHsgbGF0aXR1ZGU6IG51bWJlciwgbG9uZ2l0dWRlOiBudW1iZXIgfSkge1xuICAgIGNvbnN0IHRvRGVnID0gKHJhZDogbnVtYmVyKSA9PiBDZXNpdW0uTWF0aC50b0RlZ3JlZXMocmFkKTtcbiAgICBjb25zdCBmaXJzdFBvaW50ID0gbmV3IExhdExvblZlY3RvcnModG9EZWcoZmlyc3QubGF0aXR1ZGUpLCB0b0RlZyhmaXJzdC5sb25naXR1ZGUpKTtcbiAgICBjb25zdCBzZWNvbmRQb2ludCA9IG5ldyBMYXRMb25WZWN0b3JzKHRvRGVnKHNlY29uZC5sYXRpdHVkZSksIHRvRGVnKHNlY29uZC5sb25naXR1ZGUpKTtcbiAgICBjb25zdCBtaWRkbGVQb2ludDogYW55ID0gZmlyc3RQb2ludC5taWRwb2ludFRvKHNlY29uZFBvaW50KTtcblxuICAgIHJldHVybiBDZXNpdW0uQ2FydGVzaWFuMy5mcm9tRGVncmVlcyhtaWRkbGVQb2ludC5sb24sIG1pZGRsZVBvaW50LmxhdCk7XG4gIH1cblxuICBtaWRkbGVQb2ludEJ5U2NyZWVuKHBvc2l0aW9uMDogQ2FydGVzaWFuMywgcG9zaXRpb24xOiBDYXJ0ZXNpYW4zKTogQ2FydGVzaWFuMyB7XG4gICAgY29uc3Qgc2NlbmUgPSB0aGlzLmNlc2l1bVNlcnZpY2UuZ2V0U2NlbmUoKTtcbiAgICBjb25zdCBzY3JlZW5Qb3NpdGlvbjEgPSBDZXNpdW0uU2NlbmVUcmFuc2Zvcm1zLndnczg0VG9XaW5kb3dDb29yZGluYXRlcyhzY2VuZSwgcG9zaXRpb24wKTtcbiAgICBjb25zdCBzY3JlZW5Qb3NpdGlvbjIgPSBDZXNpdW0uU2NlbmVUcmFuc2Zvcm1zLndnczg0VG9XaW5kb3dDb29yZGluYXRlcyhzY2VuZSwgcG9zaXRpb24xKTtcbiAgICBjb25zdCBtaWRkbGVTY3JlZW5Qb2ludCA9XG4gICAgICBuZXcgQ2VzaXVtLkNhcnRlc2lhbjIoKHNjcmVlblBvc2l0aW9uMi54ICsgc2NyZWVuUG9zaXRpb24xLngpIC8gMi4wLCAoc2NyZWVuUG9zaXRpb24yLnkgKyBzY3JlZW5Qb3NpdGlvbjEueSkgLyAyLjApO1xuICAgIHJldHVybiBzY2VuZS5waWNrUG9zaXRpb24obWlkZGxlU2NyZWVuUG9pbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIGluaXRpYWwgYmVhcmluZyBiZXR3ZWVuIHR3byBwb2ludHNcbiAgICpcbiAgICogKiBAcmV0dXJuIGJlYXJpbmcgaW4gZGVncmVlc1xuICAgKiBAcGFyYW0gZmlyc3QgLSB7bGF0aXR1ZGUsbG9uZ2l0dWRlfSBpbiByYWRpYW5zXG4gICAqIEBwYXJhbSBzZWNvbmQgLSB7bGF0aXR1ZGUsbG9uZ2l0dWRlfSBpbiByYWRpYW5zXG4gICAqL1xuICBiZWFyaW5nVG8oZmlyc3Q6IHsgbGF0aXR1ZGU6IG51bWJlciwgbG9uZ2l0dWRlOiBudW1iZXIgfSwgc2Vjb25kOiB7IGxhdGl0dWRlOiBudW1iZXIsIGxvbmdpdHVkZTogbnVtYmVyIH0pIHtcbiAgICBjb25zdCB0b0RlZyA9IChyYWQ6IG51bWJlcikgPT4gQ2VzaXVtLk1hdGgudG9EZWdyZWVzKHJhZCk7XG4gICAgY29uc3QgZmlyc3RQb2ludCA9IG5ldyBMYXRMb25WZWN0b3JzKHRvRGVnKGZpcnN0LmxhdGl0dWRlKSwgdG9EZWcoZmlyc3QubG9uZ2l0dWRlKSk7XG4gICAgY29uc3Qgc2Vjb25kUG9pbnQgPSBuZXcgTGF0TG9uVmVjdG9ycyh0b0RlZyhzZWNvbmQubGF0aXR1ZGUpLCB0b0RlZyhzZWNvbmQubG9uZ2l0dWRlKSk7XG4gICAgY29uc3QgYmVhcmluZyA9IGZpcnN0UG9pbnQuYmVhcmluZ1RvKHNlY29uZFBvaW50KTtcblxuICAgIHJldHVybiBiZWFyaW5nO1xuICB9XG5cbiAgLyoqXG4gICAqIGluaXRpYWwgYmVhcmluZyBiZXR3ZWVuIHR3byBwb2ludHNcbiAgICpcbiAgICogQHJldHVybiBiZWFyaW5nIGluIGRlZ3JlZXNcbiAgICovXG4gIGJlYXJpbmdUb0NhcnRlc2lhbihmaXJzdENhcnRlc2lhbjM6IENhcnRlc2lhbjMsIHNlY29uZENhcnRlc2lhbjM6IENhcnRlc2lhbjMpIHtcbiAgICBjb25zdCBmaXJzdENhcnQgPSBDZXNpdW0uQ2FydG9ncmFwaGljLmZyb21DYXJ0ZXNpYW4oZmlyc3RDYXJ0ZXNpYW4zKTtcbiAgICBjb25zdCBzZWNvbmRDYXJ0ID0gQ2VzaXVtLkNhcnRvZ3JhcGhpYy5mcm9tQ2FydGVzaWFuKHNlY29uZENhcnRlc2lhbjMpO1xuXG4gICAgcmV0dXJuIHRoaXMuYmVhcmluZ1RvKGZpcnN0Q2FydCwgc2Vjb25kQ2FydCk7XG4gIH1cbn1cbiJdfQ==