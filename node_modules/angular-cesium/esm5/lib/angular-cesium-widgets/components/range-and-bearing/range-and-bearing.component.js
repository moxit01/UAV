/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { ChangeDetectionStrategy, Component, Input } from '@angular/core';
import { CoordinateConverter } from '../../../angular-cesium/services/coordinate-converter/coordinate-converter.service';
import { EditActions } from '../../models/edit-actions.enum';
import { EditModes } from '../../models/edit-mode.enum';
import { PolylinesEditorService } from '../../services/entity-editors/polyline-editor/polylines-editor.service';
/**
 *
 * Range and bearing component that is used to draw range and bearing on the map.
 * The inputs are used to customize the range and bearing style and behavior.
 * Create component reference and use the `create()` function to start creating R&B on the map.
 * The function receives an optional RangeAndBearingOptions object that defines the created range and bearing style and behavior
 * (on top of the default and global definitions).
 *
 * Usage:
 *
 * my-component.ts:
 *
 * ```
 * \\@ViewChild('rangeAndBearing', {static: false}) private rangeAndBearing: RangeAndBearingComponent; // Get R&B reference
 *  // ...
 * this.rangeAndBearing.create({style: { pointProps: { pixelSize: 12 } }, bearingLabelsStyle: { fillColor: Cesium.Color.GREEN } });
 * ```
 *
 * my-component.html
 * ```
 * <range-and-bearing #rangeAndBearing></range-and-bearing> // Optional inputs defines global style and behavior.
 * ```
 *
 */
var RangeAndBearingComponent = /** @class */ (function () {
    function RangeAndBearingComponent(polylineEditor, coordinateConverter) {
        this.polylineEditor = polylineEditor;
        this.coordinateConverter = coordinateConverter;
        this.lineEditOptions = {};
        this.labelsStyle = {};
        this.distanceLabelsStyle = {};
        this.bearingLabelsStyle = {};
    }
    /**
     * @param {?=} __0
     * @return {?}
     */
    RangeAndBearingComponent.prototype.create = /**
     * @param {?=} __0
     * @return {?}
     */
    function (_a) {
        var _this = this;
        var _b = _a === void 0 ? { lineEditOptions: {}, labelsStyle: {}, distanceLabelsStyle: {}, bearingLabelsStyle: {} } : _a, _c = _b.lineEditOptions, lineEditOptions = _c === void 0 ? {} : _c, _d = _b.labelsStyle, labelsStyle = _d === void 0 ? {} : _d, _e = _b.distanceLabelsStyle, distanceLabelsStyle = _e === void 0 ? {} : _e, _f = _b.bearingLabelsStyle, bearingLabelsStyle = _f === void 0 ? {} : _f, bearingStringFn = _b.bearingStringFn, distanceStringFn = _b.distanceStringFn, labelsRenderFn = _b.labelsRenderFn;
        /** @type {?} */
        var rnb = this.polylineEditor.create(tslib_1.__assign({ allowDrag: false, pointProps: {
                showVirtual: false,
                pixelSize: 8,
            }, polylineProps: {
                width: 2,
            } }, this.lineEditOptions, lineEditOptions));
        if (labelsRenderFn) {
            rnb.setLabelsRenderFn(labelsRenderFn);
        }
        else if (this.labelsRenderFn) {
            rnb.setLabelsRenderFn(this.labelsRenderFn);
        }
        else {
            rnb.setLabelsRenderFn(function (update) {
                /** @type {?} */
                var positions = update.positions;
                /** @type {?} */
                var totalDistance = 0;
                if (!positions || positions.length === 0) {
                    return [];
                }
                return (update.editMode === EditModes.CREATE && update.editAction !== EditActions.ADD_LAST_POINT
                    ? tslib_1.__spread(positions, [update.updatedPosition]) : positions).reduce(function (labels, position, index, array) {
                    if (index !== 0) {
                        /** @type {?} */
                        var previousPosition = array[index - 1];
                        /** @type {?} */
                        var bearing = _this.coordinateConverter.bearingToCartesian(previousPosition, position);
                        /** @type {?} */
                        var distance = Cesium.Cartesian3.distance(previousPosition, position) / 1000;
                        labels.push(tslib_1.__assign({ text: (bearingStringFn && bearingStringFn(bearing)) ||
                                (_this.bearingStringFn && _this.bearingStringFn(bearing)) ||
                                bearing.toFixed(2) + "\u00B0", scale: 0.2, font: '80px Helvetica', pixelOffset: new Cesium.Cartesian2(-20, -8), position: new Cesium.Cartesian3((position.x + previousPosition.x) / 2, (position.y + previousPosition.y) / 2, (position.z + previousPosition.z) / 2), fillColor: Cesium.Color.WHITE, outlineColor: Cesium.Color.WHITE, showBackground: true }, ((/** @type {?} */ (_this.labelsStyle))), ((/** @type {?} */ (labelsStyle))), ((/** @type {?} */ (_this.bearingLabelsStyle))), ((/** @type {?} */ (bearingLabelsStyle)))), tslib_1.__assign({ text: (distanceStringFn && distanceStringFn(totalDistance + distance)) ||
                                (_this.distanceStringFn && _this.distanceStringFn(totalDistance + distance)) ||
                                (totalDistance + distance).toFixed(2) + " Km", scale: 0.2, font: '80px Helvetica', pixelOffset: new Cesium.Cartesian2(-35, -8), position: position, fillColor: Cesium.Color.WHITE, outlineColor: Cesium.Color.WHITE, showBackground: true }, ((/** @type {?} */ (_this.labelsStyle))), ((/** @type {?} */ (labelsStyle))), ((/** @type {?} */ (_this.distanceLabelsStyle))), ((/** @type {?} */ (distanceLabelsStyle)))));
                        totalDistance += distance;
                    }
                    return labels;
                }, [
                    tslib_1.__assign({ text: (distanceStringFn && distanceStringFn(0)) || (_this.distanceStringFn && _this.distanceStringFn(0)) || "0 Km", scale: 0.2, font: '80px Helvetica', pixelOffset: new Cesium.Cartesian2(-20, -8), position: positions[0], fillColor: Cesium.Color.WHITE, outlineColor: Cesium.Color.WHITE, showBackground: true }, ((/** @type {?} */ (_this.labelsStyle))), ((/** @type {?} */ (labelsStyle))), ((/** @type {?} */ (_this.distanceLabelsStyle))), ((/** @type {?} */ (distanceLabelsStyle)))),
                ]);
            });
        }
        return rnb;
    };
    RangeAndBearingComponent.decorators = [
        { type: Component, args: [{
                    selector: 'range-and-bearing',
                    template: "\n    <polylines-editor></polylines-editor>\n  ",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [PolylinesEditorService]
                }] }
    ];
    /** @nocollapse */
    RangeAndBearingComponent.ctorParameters = function () { return [
        { type: PolylinesEditorService },
        { type: CoordinateConverter }
    ]; };
    RangeAndBearingComponent.propDecorators = {
        lineEditOptions: [{ type: Input }],
        labelsStyle: [{ type: Input }],
        distanceLabelsStyle: [{ type: Input }],
        bearingLabelsStyle: [{ type: Input }],
        bearingStringFn: [{ type: Input }],
        distanceStringFn: [{ type: Input }],
        labelsRenderFn: [{ type: Input }]
    };
    return RangeAndBearingComponent;
}());
export { RangeAndBearingComponent };
if (false) {
    /** @type {?} */
    RangeAndBearingComponent.prototype.lineEditOptions;
    /** @type {?} */
    RangeAndBearingComponent.prototype.labelsStyle;
    /** @type {?} */
    RangeAndBearingComponent.prototype.distanceLabelsStyle;
    /** @type {?} */
    RangeAndBearingComponent.prototype.bearingLabelsStyle;
    /** @type {?} */
    RangeAndBearingComponent.prototype.bearingStringFn;
    /** @type {?} */
    RangeAndBearingComponent.prototype.distanceStringFn;
    /** @type {?} */
    RangeAndBearingComponent.prototype.labelsRenderFn;
    /**
     * @type {?}
     * @private
     */
    RangeAndBearingComponent.prototype.polylineEditor;
    /**
     * @type {?}
     * @private
     */
    RangeAndBearingComponent.prototype.coordinateConverter;
}
/**
 * @record
 */
export function RangeAndBearingOptions() { }
if (false) {
    /** @type {?|undefined} */
    RangeAndBearingOptions.prototype.lineEditOptions;
    /** @type {?|undefined} */
    RangeAndBearingOptions.prototype.labelsStyle;
    /** @type {?|undefined} */
    RangeAndBearingOptions.prototype.distanceLabelsStyle;
    /** @type {?|undefined} */
    RangeAndBearingOptions.prototype.bearingLabelsStyle;
    /** @type {?|undefined} */
    RangeAndBearingOptions.prototype.bearingStringFn;
    /** @type {?|undefined} */
    RangeAndBearingOptions.prototype.distanceStringFn;
    /** @type {?|undefined} */
    RangeAndBearingOptions.prototype.labelsRenderFn;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmFuZ2UtYW5kLWJlYXJpbmcuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vYW5ndWxhci1jZXNpdW0vIiwic291cmNlcyI6WyJsaWIvYW5ndWxhci1jZXNpdW0td2lkZ2V0cy9jb21wb25lbnRzL3JhbmdlLWFuZC1iZWFyaW5nL3JhbmdlLWFuZC1iZWFyaW5nLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLE9BQU8sRUFBRSx1QkFBdUIsRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzFFLE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxNQUFNLG9GQUFvRixDQUFDO0FBQ3pILE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxnQ0FBZ0MsQ0FBQztBQUs3RCxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sNkJBQTZCLENBQUM7QUFDeEQsT0FBTyxFQUFFLHNCQUFzQixFQUFFLE1BQU0sd0VBQXdFLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEwQmhIO0lBaUJFLGtDQUFvQixjQUFzQyxFQUFVLG1CQUF3QztRQUF4RixtQkFBYyxHQUFkLGNBQWMsQ0FBd0I7UUFBVSx3QkFBbUIsR0FBbkIsbUJBQW1CLENBQXFCO1FBUm5HLG9CQUFlLEdBQXlCLEVBQUUsQ0FBQztRQUMzQyxnQkFBVyxHQUFnQixFQUFFLENBQUM7UUFDOUIsd0JBQW1CLEdBQWdCLEVBQUUsQ0FBQztRQUN0Qyx1QkFBa0IsR0FBZ0IsRUFBRSxDQUFDO0lBTTlDLENBQUM7Ozs7O0lBRUQseUNBQU07Ozs7SUFBTixVQUNFLEVBUW1IO1FBVHJILGlCQStHQztZQTlHQyxtSEFRbUgsRUFQakgsdUJBQW9CLEVBQXBCLHlDQUFvQixFQUNwQixtQkFBZ0IsRUFBaEIscUNBQWdCLEVBQ2hCLDJCQUF3QixFQUF4Qiw2Q0FBd0IsRUFDeEIsMEJBQXVCLEVBQXZCLDRDQUF1QixFQUN2QixvQ0FBZSxFQUNmLHNDQUFnQixFQUNoQixrQ0FB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QUM1QyxrREFBNkM7O0lBQzdDLGdEQUFvRiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDb21wb25lbnQsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb29yZGluYXRlQ29udmVydGVyIH0gZnJvbSAnLi4vLi4vLi4vYW5ndWxhci1jZXNpdW0vc2VydmljZXMvY29vcmRpbmF0ZS1jb252ZXJ0ZXIvY29vcmRpbmF0ZS1jb252ZXJ0ZXIuc2VydmljZSc7XG5pbXBvcnQgeyBFZGl0QWN0aW9ucyB9IGZyb20gJy4uLy4uL21vZGVscy9lZGl0LWFjdGlvbnMuZW51bSc7XG5pbXBvcnQgeyBQb2x5bGluZUVkaXRvck9ic2VydmFibGUgfSBmcm9tICcuLi8uLi9tb2RlbHMvcG9seWxpbmUtZWRpdG9yLW9ic2VydmFibGUnO1xuaW1wb3J0IHsgUG9seWxpbmVFZGl0T3B0aW9ucyB9IGZyb20gJy4uLy4uL21vZGVscy9wb2x5bGluZS1lZGl0LW9wdGlvbnMnO1xuaW1wb3J0IHsgTGFiZWxQcm9wcywgTGFiZWxTdHlsZSB9IGZyb20gJy4uLy4uL21vZGVscy9sYWJlbC1wcm9wcyc7XG5pbXBvcnQgeyBQb2x5bGluZUVkaXRVcGRhdGUgfSBmcm9tICcuLi8uLi9tb2RlbHMvcG9seWxpbmUtZWRpdC11cGRhdGUnO1xuaW1wb3J0IHsgRWRpdE1vZGVzIH0gZnJvbSAnLi4vLi4vbW9kZWxzL2VkaXQtbW9kZS5lbnVtJztcbmltcG9ydCB7IFBvbHlsaW5lc0VkaXRvclNlcnZpY2UgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9lbnRpdHktZWRpdG9ycy9wb2x5bGluZS1lZGl0b3IvcG9seWxpbmVzLWVkaXRvci5zZXJ2aWNlJztcblxuLyoqXG4gKlxuICogUmFuZ2UgYW5kIGJlYXJpbmcgY29tcG9uZW50IHRoYXQgaXMgdXNlZCB0byBkcmF3IHJhbmdlIGFuZCBiZWFyaW5nIG9uIHRoZSBtYXAuXG4gKiBUaGUgaW5wdXRzIGFyZSB1c2VkIHRvIGN1c3RvbWl6ZSB0aGUgcmFuZ2UgYW5kIGJlYXJpbmcgc3R5bGUgYW5kIGJlaGF2aW9yLlxuICogQ3JlYXRlIGNvbXBvbmVudCByZWZlcmVuY2UgYW5kIHVzZSB0aGUgYGNyZWF0ZSgpYCBmdW5jdGlvbiB0byBzdGFydCBjcmVhdGluZyBSJkIgb24gdGhlIG1hcC5cbiAqIFRoZSBmdW5jdGlvbiByZWNlaXZlcyBhbiBvcHRpb25hbCBSYW5nZUFuZEJlYXJpbmdPcHRpb25zIG9iamVjdCB0aGF0IGRlZmluZXMgdGhlIGNyZWF0ZWQgcmFuZ2UgYW5kIGJlYXJpbmcgc3R5bGUgYW5kIGJlaGF2aW9yXG4gKiAob24gdG9wIG9mIHRoZSBkZWZhdWx0IGFuZCBnbG9iYWwgZGVmaW5pdGlvbnMpLlxuICpcbiAqIFVzYWdlOlxuICpcbiAqIG15LWNvbXBvbmVudC50czpcbiAqXG4gKiBgYGBcbiAqIFxcQFZpZXdDaGlsZCgncmFuZ2VBbmRCZWFyaW5nJywge3N0YXRpYzogZmFsc2V9KSBwcml2YXRlIHJhbmdlQW5kQmVhcmluZzogUmFuZ2VBbmRCZWFyaW5nQ29tcG9uZW50OyAvLyBHZXQgUiZCIHJlZmVyZW5jZVxuICogIC8vIC4uLlxuICogdGhpcy5yYW5nZUFuZEJlYXJpbmcuY3JlYXRlKHtzdHlsZTogeyBwb2ludFByb3BzOiB7IHBpeGVsU2l6ZTogMTIgfSB9LCBiZWFyaW5nTGFiZWxzU3R5bGU6IHsgZmlsbENvbG9yOiBDZXNpdW0uQ29sb3IuR1JFRU4gfSB9KTtcbiAqIGBgYFxuICpcbiAqIG15LWNvbXBvbmVudC5odG1sXG4gKiBgYGBcbiAqIDxyYW5nZS1hbmQtYmVhcmluZyAjcmFuZ2VBbmRCZWFyaW5nPjwvcmFuZ2UtYW5kLWJlYXJpbmc+IC8vIE9wdGlvbmFsIGlucHV0cyBkZWZpbmVzIGdsb2JhbCBzdHlsZSBhbmQgYmVoYXZpb3IuXG4gKiBgYGBcbiAqXG4gKi9cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ3JhbmdlLWFuZC1iZWFyaW5nJyxcbiAgdGVtcGxhdGU6IGBcbiAgICA8cG9seWxpbmVzLWVkaXRvcj48L3BvbHlsaW5lcy1lZGl0b3I+XG4gIGAsXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICBwcm92aWRlcnM6IFtQb2x5bGluZXNFZGl0b3JTZXJ2aWNlXSxcbn0pXG5leHBvcnQgY2xhc3MgUmFuZ2VBbmRCZWFyaW5nQ29tcG9uZW50IHtcbiAgQElucHV0KCkgbGluZUVkaXRPcHRpb25zPzogUG9seWxpbmVFZGl0T3B0aW9ucyA9IHt9O1xuICBASW5wdXQoKSBsYWJlbHNTdHlsZT86IExhYmVsU3R5bGUgPSB7fTtcbiAgQElucHV0KCkgZGlzdGFuY2VMYWJlbHNTdHlsZT86IExhYmVsU3R5bGUgPSB7fTtcbiAgQElucHV0KCkgYmVhcmluZ0xhYmVsc1N0eWxlPzogTGFiZWxTdHlsZSA9IHt9O1xuICBASW5wdXQoKSBiZWFyaW5nU3RyaW5nRm4/OiAodmFsdWU6IG51bWJlcikgPT4gc3RyaW5nO1xuICBASW5wdXQoKSBkaXN0YW5jZVN0cmluZ0ZuPzogKHZhbHVlOiBudW1iZXIpID0+IHN0cmluZztcbiAgQElucHV0KCkgbGFiZWxzUmVuZGVyRm4/OiAodXBkYXRlOiBQb2x5bGluZUVkaXRVcGRhdGUsIGxhYmVsczogTGFiZWxQcm9wc1tdKSA9PiBMYWJlbFByb3BzW107XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBwb2x5bGluZUVkaXRvcjogUG9seWxpbmVzRWRpdG9yU2VydmljZSwgcHJpdmF0ZSBjb29yZGluYXRlQ29udmVydGVyOiBDb29yZGluYXRlQ29udmVydGVyKSB7XG4gIH1cblxuICBjcmVhdGUoXG4gICAge1xuICAgICAgbGluZUVkaXRPcHRpb25zID0ge30sXG4gICAgICBsYWJlbHNTdHlsZSA9IHt9LFxuICAgICAgZGlzdGFuY2VMYWJlbHNTdHlsZSA9IHt9LFxuICAgICAgYmVhcmluZ0xhYmVsc1N0eWxlID0ge30sXG4gICAgICBiZWFyaW5nU3RyaW5nRm4sXG4gICAgICBkaXN0YW5jZVN0cmluZ0ZuLFxuICAgICAgbGFiZWxzUmVuZGVyRm4sXG4gICAgfTogUmFuZ2VBbmRCZWFyaW5nT3B0aW9ucyA9IHtsaW5lRWRpdE9wdGlvbnM6IHt9LCBsYWJlbHNTdHlsZToge30sIGRpc3RhbmNlTGFiZWxzU3R5bGU6IHt9LCBiZWFyaW5nTGFiZWxzU3R5bGU6IHt9fSxcbiAgKTogUG9seWxpbmVFZGl0b3JPYnNlcnZhYmxlIHtcbiAgICBjb25zdCBybmIgPSB0aGlzLnBvbHlsaW5lRWRpdG9yLmNyZWF0ZSh7XG4gICAgICBhbGxvd0RyYWc6IGZhbHNlLFxuICAgICAgcG9pbnRQcm9wczoge1xuICAgICAgICBzaG93VmlydHVhbDogZmFsc2UsXG4gICAgICAgIHBpeGVsU2l6ZTogOCxcbiAgICAgIH0sXG4gICAgICBwb2x5bGluZVByb3BzOiB7XG4gICAgICAgIHdpZHRoOiAyLFxuICAgICAgfSxcbiAgICAgIC4uLnRoaXMubGluZUVkaXRPcHRpb25zLFxuICAgICAgLi4ubGluZUVkaXRPcHRpb25zLFxuICAgIH0pO1xuXG4gICAgaWYgKGxhYmVsc1JlbmRlckZuKSB7XG4gICAgICBybmIuc2V0TGFiZWxzUmVuZGVyRm4obGFiZWxzUmVuZGVyRm4pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5sYWJlbHNSZW5kZXJGbikge1xuICAgICAgcm5iLnNldExhYmVsc1JlbmRlckZuKHRoaXMubGFiZWxzUmVuZGVyRm4pO1xuICAgIH0gZWxzZSB7XG4gICAgICBybmIuc2V0TGFiZWxzUmVuZGVyRm4odXBkYXRlID0+IHtcbiAgICAgICAgY29uc3QgcG9zaXRpb25zID0gdXBkYXRlLnBvc2l0aW9ucztcbiAgICAgICAgbGV0IHRvdGFsRGlzdGFuY2UgPSAwO1xuICAgICAgICBpZiAoIXBvc2l0aW9ucyB8fCBwb3NpdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAodXBkYXRlLmVkaXRNb2RlID09PSBFZGl0TW9kZXMuQ1JFQVRFICYmIHVwZGF0ZS5lZGl0QWN0aW9uICE9PSBFZGl0QWN0aW9ucy5BRERfTEFTVF9QT0lOVFxuICAgICAgICAgICAgPyBbLi4ucG9zaXRpb25zLCB1cGRhdGUudXBkYXRlZFBvc2l0aW9uXVxuICAgICAgICAgICAgOiBwb3NpdGlvbnNcbiAgICAgICAgKS5yZWR1Y2UoXG4gICAgICAgICAgKGxhYmVscywgcG9zaXRpb24sIGluZGV4LCBhcnJheSkgPT4ge1xuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAwKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzUG9zaXRpb24gPSBhcnJheVtpbmRleCAtIDFdO1xuICAgICAgICAgICAgICBjb25zdCBiZWFyaW5nID0gdGhpcy5jb29yZGluYXRlQ29udmVydGVyLmJlYXJpbmdUb0NhcnRlc2lhbihwcmV2aW91c1Bvc2l0aW9uLCBwb3NpdGlvbik7XG4gICAgICAgICAgICAgIGNvbnN0IGRpc3RhbmNlID0gQ2VzaXVtLkNhcnRlc2lhbjMuZGlzdGFuY2UocHJldmlvdXNQb3NpdGlvbiwgcG9zaXRpb24pIC8gMTAwMDtcbiAgICAgICAgICAgICAgbGFiZWxzLnB1c2goXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgdGV4dDpcbiAgICAgICAgICAgICAgICAgICAgKGJlYXJpbmdTdHJpbmdGbiAmJiBiZWFyaW5nU3RyaW5nRm4oYmVhcmluZykpIHx8XG4gICAgICAgICAgICAgICAgICAgICh0aGlzLmJlYXJpbmdTdHJpbmdGbiAmJiB0aGlzLmJlYXJpbmdTdHJpbmdGbihiZWFyaW5nKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgYCR7YmVhcmluZy50b0ZpeGVkKDIpfcKwYCxcbiAgICAgICAgICAgICAgICAgIHNjYWxlOiAwLjIsXG4gICAgICAgICAgICAgICAgICBmb250OiAnODBweCBIZWx2ZXRpY2EnLFxuICAgICAgICAgICAgICAgICAgcGl4ZWxPZmZzZXQ6IG5ldyBDZXNpdW0uQ2FydGVzaWFuMigtMjAsIC04KSxcbiAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBuZXcgQ2VzaXVtLkNhcnRlc2lhbjMoXG4gICAgICAgICAgICAgICAgICAgIChwb3NpdGlvbi54ICsgcHJldmlvdXNQb3NpdGlvbi54KSAvIDIsXG4gICAgICAgICAgICAgICAgICAgIChwb3NpdGlvbi55ICsgcHJldmlvdXNQb3NpdGlvbi55KSAvIDIsXG4gICAgICAgICAgICAgICAgICAgIChwb3NpdGlvbi56ICsgcHJldmlvdXNQb3NpdGlvbi56KSAvIDIsXG4gICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgZmlsbENvbG9yOiBDZXNpdW0uQ29sb3IuV0hJVEUsXG4gICAgICAgICAgICAgICAgICBvdXRsaW5lQ29sb3I6IENlc2l1bS5Db2xvci5XSElURSxcbiAgICAgICAgICAgICAgICAgIHNob3dCYWNrZ3JvdW5kOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgLi4uKHRoaXMubGFiZWxzU3R5bGUgYXMgYW55KSxcbiAgICAgICAgICAgICAgICAgIC4uLihsYWJlbHNTdHlsZSBhcyBhbnkpLFxuICAgICAgICAgICAgICAgICAgLi4uKHRoaXMuYmVhcmluZ0xhYmVsc1N0eWxlIGFzIGFueSksXG4gICAgICAgICAgICAgICAgICAuLi4oYmVhcmluZ0xhYmVsc1N0eWxlIGFzIGFueSksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB0ZXh0OlxuICAgICAgICAgICAgICAgICAgICAoZGlzdGFuY2VTdHJpbmdGbiAmJiBkaXN0YW5jZVN0cmluZ0ZuKHRvdGFsRGlzdGFuY2UgKyBkaXN0YW5jZSkpIHx8XG4gICAgICAgICAgICAgICAgICAgICh0aGlzLmRpc3RhbmNlU3RyaW5nRm4gJiYgdGhpcy5kaXN0YW5jZVN0cmluZ0ZuKHRvdGFsRGlzdGFuY2UgKyBkaXN0YW5jZSkpIHx8XG4gICAgICAgICAgICAgICAgICAgIGAkeyh0b3RhbERpc3RhbmNlICsgZGlzdGFuY2UpLnRvRml4ZWQoMil9IEttYCxcbiAgICAgICAgICAgICAgICAgIHNjYWxlOiAwLjIsXG4gICAgICAgICAgICAgICAgICBmb250OiAnODBweCBIZWx2ZXRpY2EnLFxuICAgICAgICAgICAgICAgICAgcGl4ZWxPZmZzZXQ6IG5ldyBDZXNpdW0uQ2FydGVzaWFuMigtMzUsIC04KSxcbiAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgIGZpbGxDb2xvcjogQ2VzaXVtLkNvbG9yLldISVRFLFxuICAgICAgICAgICAgICAgICAgb3V0bGluZUNvbG9yOiBDZXNpdW0uQ29sb3IuV0hJVEUsXG4gICAgICAgICAgICAgICAgICBzaG93QmFja2dyb3VuZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgIC4uLih0aGlzLmxhYmVsc1N0eWxlIGFzIGFueSksXG4gICAgICAgICAgICAgICAgICAuLi4obGFiZWxzU3R5bGUgYXMgYW55KSxcbiAgICAgICAgICAgICAgICAgIC4uLih0aGlzLmRpc3RhbmNlTGFiZWxzU3R5bGUgYXMgYW55KSxcbiAgICAgICAgICAgICAgICAgIC4uLihkaXN0YW5jZUxhYmVsc1N0eWxlIGFzIGFueSksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICB0b3RhbERpc3RhbmNlICs9IGRpc3RhbmNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbGFiZWxzO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0ZXh0OiAoZGlzdGFuY2VTdHJpbmdGbiAmJiBkaXN0YW5jZVN0cmluZ0ZuKDApKSB8fCAodGhpcy5kaXN0YW5jZVN0cmluZ0ZuICYmIHRoaXMuZGlzdGFuY2VTdHJpbmdGbigwKSkgfHwgYDAgS21gLFxuICAgICAgICAgICAgICBzY2FsZTogMC4yLFxuICAgICAgICAgICAgICBmb250OiAnODBweCBIZWx2ZXRpY2EnLFxuICAgICAgICAgICAgICBwaXhlbE9mZnNldDogbmV3IENlc2l1bS5DYXJ0ZXNpYW4yKC0yMCwgLTgpLFxuICAgICAgICAgICAgICBwb3NpdGlvbjogcG9zaXRpb25zWzBdLFxuICAgICAgICAgICAgICBmaWxsQ29sb3I6IENlc2l1bS5Db2xvci5XSElURSxcbiAgICAgICAgICAgICAgb3V0bGluZUNvbG9yOiBDZXNpdW0uQ29sb3IuV0hJVEUsXG4gICAgICAgICAgICAgIHNob3dCYWNrZ3JvdW5kOiB0cnVlLFxuICAgICAgICAgICAgICAuLi4odGhpcy5sYWJlbHNTdHlsZSBhcyBhbnkpLFxuICAgICAgICAgICAgICAuLi4obGFiZWxzU3R5bGUgYXMgYW55KSxcbiAgICAgICAgICAgICAgLi4uKHRoaXMuZGlzdGFuY2VMYWJlbHNTdHlsZSBhcyBhbnkpLFxuICAgICAgICAgICAgICAuLi4oZGlzdGFuY2VMYWJlbHNTdHlsZSBhcyBhbnkpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICBdLFxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJuYjtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJhbmdlQW5kQmVhcmluZ09wdGlvbnMge1xuICBsaW5lRWRpdE9wdGlvbnM/OiBQb2x5bGluZUVkaXRPcHRpb25zO1xuICBsYWJlbHNTdHlsZT86IExhYmVsU3R5bGU7XG4gIGRpc3RhbmNlTGFiZWxzU3R5bGU/OiBMYWJlbFN0eWxlO1xuICBiZWFyaW5nTGFiZWxzU3R5bGU/OiBMYWJlbFN0eWxlO1xuICBiZWFyaW5nU3RyaW5nRm4/OiAodmFsdWU6IG51bWJlcikgPT4gc3RyaW5nO1xuICBkaXN0YW5jZVN0cmluZ0ZuPzogKHZhbHVlOiBudW1iZXIpID0+IHN0cmluZztcbiAgbGFiZWxzUmVuZGVyRm4/OiAodXBkYXRlOiBQb2x5bGluZUVkaXRVcGRhdGUsIGxhYmVsczogTGFiZWxQcm9wc1tdKSA9PiBMYWJlbFByb3BzW107XG59XG4iXX0=