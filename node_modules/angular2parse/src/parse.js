import { Inject, Injectable, InjectionToken, Optional } from '@angular/core';
import { Parser, Lexer } from './angular';
import { ParseVisitorResolver, ParseVisitorCompiler } from './visitors';
export var PIPES_CONFIG = new InjectionToken('PipesConfig');
var Parse = /** @class */ (function () {
    /**
     * Used to dependency inject the Angular 2 parser.
     */
    function Parse(pipesConfigs) {
        var _this = this;
        this._parser = new Parser(new Lexer());
        this._pipesCache = new Map();
        this._evalCache = new Map();
        this._calcCache = new Map();
        if (pipesConfigs && pipesConfigs.length) {
            pipesConfigs
                .filter(function (pipes) { return pipes && pipes.length; })
                .forEach(function (pipes) { return pipes.forEach(function (pipeData) { return _this._pipesCache.set(pipeData.pipeName, pipeData.pipeInstance); }); });
        }
    }
    Parse.prototype.eval = function (expression) {
        if (this._evalCache.has(expression)) {
            return this._evalCache.get(expression);
        }
        var visitor = new ParseVisitorCompiler();
        var ast = this._parser.parseInterpolation(expression, 'Parse');
        if (!ast) {
            ast = this._parser.parseBinding(expression, 'Parse');
        }
        var fnBody = ast.visit(visitor);
        var pipesCache = this._pipesCache;
        var getFn = new Function('context', 'pipesCache', "return " + fnBody + ";");
        var evalParse = function evalParse(context) {
            return getFn(context, pipesCache);
        };
        this._evalCache.set(expression, evalParse);
        return evalParse;
    };
    Parse.prototype.calc = function (expression) {
        if (this._calcCache.has(expression)) {
            return this._calcCache.get(expression);
        }
        var visitor = new ParseVisitorResolver(this._pipesCache);
        var ast = this._parser.parseInterpolation(expression, 'Parse');
        if (!ast) {
            ast = this._parser.parseBinding(expression, 'Parse');
        }
        var calcParse = function calcParse(context) {
            return ast.visit(visitor, context);
        };
        this._calcCache.set(expression, calcParse);
        return calcParse;
    };
    Parse.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    Parse.ctorParameters = function () { return [
        { type: Array, decorators: [{ type: Optional }, { type: Inject, args: [PIPES_CONFIG,] }] }
    ]; };
    return Parse;
}());
export { Parse };
//# sourceMappingURL=parse.js.map